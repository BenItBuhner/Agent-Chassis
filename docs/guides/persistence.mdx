---
title: Session Persistence
---

Agent Chassis supports optional server-side session persistence using a dual-layer storage strategy:

- **Redis**: Fast, TTL-based cache for active sessions
- **PostgreSQL**: Durable storage for long-term persistence

## Architecture

### Storage Flow

1. **Check Redis cache first** (fast path, <1ms)
2. **On cache miss**, check PostgreSQL (durable storage)
3. **On DB hit**, repopulate Redis cache
4. **On complete miss**, create new session

### Access Control

When authentication is enabled (OSP-12):
- **New sessions** are owned by the creator
- **Only owner** can access by default
- **Public sessions** can be shared with `is_public: true`
- **Whitelist/Blacklist** for fine-grained control

## Setup

### 1. Enable Persistence

```env
ENABLE_PERSISTENCE=true
```

### 2. Configure Redis

```env
REDIS_URL=redis://localhost:6379/0
```

**Upstash Redis (Cloud):**
```env
REDIS_URL=rediss://default:password@golden-humpback-43413.upstash.io:6379
```

### 3. Configure PostgreSQL

```env
DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/agent_chassis
```

**Supabase PostgreSQL:**
```env
DATABASE_URL=postgresql+asyncpg://postgres.user:password@aws-1-us-east-2.pooler.supabase.com:5432/postgres
```

### 4. Verify Connection

Check the health endpoint:

```bash
curl http://localhost:8000/health
```

Expected response:
```json
{
  "status": "healthy",
  "persistence_enabled": true,
  "redis_connected": true,
  "database_connected": true
}
```

## Usage

> Server-side mode is only available when `ENABLE_PERSISTENCE=true` and at least one storage backend (Redis or PostgreSQL) is reachable. If persistence is off or unavailable, calls that supply `session_id` or `message` (server-side mode) will be rejected; send full `messages` instead.

### Client-Side Mode (No Persistence)

Pass full message history in request:

```json
{
  "messages": [
    {"role": "user", "content": "Hello!"},
    {"role": "assistant", "content": "Hi there!"},
    {"role": "user", "content": "What's 2+2?"}
  ],
  "model": "kimi-k2-thinking"
}
```

**Use cases:**
- Stateless API calls
- External session management
- Testing without persistence

### Server-Side Mode (With Persistence)

Use `session_id` to continue conversations:

**First request (create session):**
```json
{
  "message": "Hello!",
  "model": "kimi-k2-thinking"
}
```

**Response includes `session_id`:**
```json
{
  "role": "assistant",
  "content": "Hi there! How can I help?",
  "session_id": "abc-123-def-456"
}
```

**Continue conversation:**
```json
{
  "session_id": "abc-123-def-456",
  "message": "What's 2+2?",
  "model": "kimi-k2-thinking"
}
```

## Session Management

### Get Session Info

```bash
GET /api/v1/agent/session/{session_id}
Authorization: Bearer your-token
```

**Response:**
```json
{
  "session_id": "abc-123-def-456",
  "message_count": 5,
  "created_at": "2024-01-01T00:00:00Z",
  "updated_at": "2024-01-01T00:05:00Z",
  "owner_id": "user-uuid",
  "is_public": false
}
```

### Update Access Settings

**Make session public:**
```bash
PATCH /api/v1/agent/session/{session_id}/access
Authorization: Bearer your-token
Content-Type: application/json

{
  "is_public": true
}
```

**Share with specific users:**
```bash
PATCH /api/v1/agent/session/{session_id}/access
Authorization: Bearer your-token
Content-Type: application/json

{
  "add_to_whitelist": ["user-123", "user-456"]
}
```

**Block specific users:**
```bash
PATCH /api/v1/agent/session/{session_id}/access
Authorization: Bearer your-token
Content-Type: application/json

{
  "add_to_blacklist": ["spam-user"]
}
```

### Delete Session

```bash
DELETE /api/v1/agent/session/{session_id}
Authorization: Bearer your-token
```

**Only the session owner can delete.**

## Access Control Priority

When checking access (highest to lowest):

1. **Blacklist** - Always denied (even if public)
2. **Owner** - Always allowed
3. **Public flag** - Allows all except blacklisted
4. **Whitelist** - Explicitly allowed users
5. **Default** - Denied

## Configuration

### Session TTL

Redis cache TTL (default: 24 hours):

```env
SESSION_TTL_SECONDS=86400
```

### Max Messages

Maximum messages per session before truncation:

```env
SESSION_MAX_MESSAGES=100
```

## Graceful Degradation
If persistence is disabled or unavailable:

- **Server-side mode is blocked** – requests with `session_id`/`message` return 400 and no `session_id` is issued
- **Client-side mode** continues to work; send the full `messages` array each call
- **No silent data loss** – conversations are not “pretend saved” when storage is off

## Database Schema

### Conversation Table

```sql
CREATE TABLE conversations (
    id UUID PRIMARY KEY,
    messages JSONB NOT NULL,
    metadata JSONB,
    owner_id UUID,
    is_public BOOLEAN DEFAULT FALSE,
    access_whitelist UUID[],
    access_blacklist UUID[],
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE
);
```

## Best Practices

1. **Use server-side mode** for multi-turn conversations
2. **Set appropriate TTL** based on your use case
3. **Enable access control** for multi-user deployments
4. **Monitor Redis memory** usage
5. **Backup PostgreSQL** regularly for critical data

## Troubleshooting

### Redis Connection Failed

- Check Redis is running: `redis-cli ping`
- Verify `REDIS_URL` format
- Check network connectivity

### PostgreSQL Connection Failed

- Verify database exists
- Check credentials in `DATABASE_URL`
- Ensure PostgreSQL is accessible

### Session Not Found

- Check `session_id` is correct
- Verify access permissions
- Check if session expired (Redis TTL)

### Access Denied

- Verify you're the session owner
- Check if session is public
- Verify you're on the whitelist (if set)





